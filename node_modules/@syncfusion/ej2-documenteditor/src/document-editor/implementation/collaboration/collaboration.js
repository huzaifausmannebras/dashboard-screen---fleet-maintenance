/* eslint-disable */
import { HelperMethods, ParagraphWidget, TableWidget, CONTROL_CHARACTERS, SectionBreakType, ListTextElementBox, ShapeElementBox, FootnoteElementBox, CommentElementBox, CommentCharacterElementBox, FieldElementBox, WCharacterFormat, ImageElementBox, WParagraphFormat, WTableFormat, WRowFormat, WCellFormat, WSectionFormat, listIdProperty, WStyles, abstractListsProperty, listsProperty, abstractListIdProperty, nsidProperty } from '../../index';
import { isNullOrUndefined } from '@syncfusion/ej2-base';
import { createElement } from '@syncfusion/ej2-base';
/**
 * @private
 */
var CollaborativeEditingHandler = /** @class */ (function () {
    function CollaborativeEditingHandler(documentEditor, roomName, version, serviceUrl) {
        //TODO need to prevent document change on collaborative editing session i.e. New document, select new document
        //#region SignalR collabrative editing
        /**
         * @private
         */
        this.version = 0;
        this.userMap = {};
        this.connectionId = '';
        this.pendingOps = [];
        this.commentsStart = [];
        this.commentsEnd = [];
        this.deletedComments = [];
        this.serviceUrl = '';
        this.isSyncServerChanges = false;
        this.logEventEnabled = true;
        this.message = '';
        this.documentEditor = documentEditor;
        this.roomName = roomName;
        this.serviceUrl = serviceUrl;
        this.version = version;
    }
    ;
    CollaborativeEditingHandler.prototype.isAcknowledgePending = function () {
        return !isNullOrUndefined(this.acknowledgmentPending);
    };
    /**
     * Update action to server.
     * @private
     * @param args
     * @returns
     */
    CollaborativeEditingHandler.prototype.sendActionServer = function (operations) {
        if (!isNullOrUndefined(operations) && operations.length === 0) {
            return;
        }
        this.pendingOps.push(operations);
        if (!this.isAcknowledgePending()) {
            this.sendLocalOperation();
        }
        this.transformRemoteCursor(this.connectionId, operations[0], operations[0].offset);
    };
    /**
     * Apply remote action to document.
     * @private
     */
    CollaborativeEditingHandler.prototype.applyAction = function (action, data) {
        switch (action) {
            case 'connectionId':
                this.connectionId = data;
                break;
            case 'removeUser':
                this.removeCarets(data);
                break;
            case 'action':
                this.dataReceived(data);
                break;
        }
    };
    CollaborativeEditingHandler.prototype.handleAcknowledgementReceived = function (action) {
        var versionDiff = this.getVersionDifference(action);
        if (versionDiff > 1) {
            this.checkAndRetriveChangesFromServer();
        }
        else {
            this.logMessage('Ack received: ' + action.version);
            this.logMessage('Ack version diff: ' + versionDiff);
            this.updateVersion(action.version);
            this.acknowledgementReceived();
            this.sendLocalOperation();
        }
    };
    CollaborativeEditingHandler.prototype.updateVersion = function (version) {
        if (version > this.version) {
            this.version = version;
        }
    };
    CollaborativeEditingHandler.prototype.acknowledgementReceived = function () {
        this.acknowledgmentPending = undefined;
    };
    //Send the local operation to server
    CollaborativeEditingHandler.prototype.sendLocalOperation = function () {
        var _this = this;
        if (this.pendingOps.length > 0) {
            var operations = this.pendingOps.shift();
            var changes = {};
            changes.currentUser = this.documentEditor.currentUser;
            changes.fileName = this.documentEditor.documentName + '.docx';
            changes.connectionId = this.connectionId;
            changes.version = this.version;
            changes.operations = operations;
            changes.timeStamp = HelperMethods.getUtcDate();
            this.acknowledgmentPending = operations;
            var httpRequest = new XMLHttpRequest();
            httpRequest.open('Post', this.serviceUrl + 'api/CollaborativeEditing/UpdateAction', true);
            httpRequest.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
            httpRequest.onreadystatechange = function () {
                if (httpRequest.readyState === 4) {
                    if (httpRequest.status === 200 || httpRequest.status === 304) {
                        var dataObject = JSON.parse(httpRequest.responseText);
                        if (!_this.isSyncServerChanges) {
                            _this.handleAcknowledgementReceived(dataObject);
                        }
                    }
                    else {
                        alert('Failed to save the changes');
                    }
                }
            };
            httpRequest.send(JSON.stringify(changes));
        }
    };
    CollaborativeEditingHandler.prototype.dataReceived = function (action) {
        if (action.connectionId === this.connectionId || this.isSyncServerChanges) {
            this.logMessage(this.isSyncServerChanges ? 'SignalR Server sync' + action.version : 'SignalR Same user sync:' + action.version);
            return;
        }
        var versionDiff = this.getVersionDifference(action);
        if (versionDiff <= 0) {
            this.logMessage('SignalR return diff:<=0' + action.version);
            return;
        }
        if (versionDiff > 1) {
            this.logMessage('SignalR return diff:>=1' + action.version);
            this.checkAndRetriveChangesFromServer();
            return;
        }
        this.logMessage('SignalR ack: ' + action.version);
        try {
            this.handleRemoteOperation(action);
        }
        catch (e) {
            this.logMessage('Error while handling remote operation: ' + e);
        }
    };
    CollaborativeEditingHandler.prototype.getVersionDifference = function (action) {
        return action.version - this.version;
    };
    CollaborativeEditingHandler.prototype.handleRemoteOperation = function (action) {
        //To Prevent the content change event while applying the remote operation
        this.documentEditor.editor.isRemoteAction = true;
        //TODO: Need to handle backward selection.
        var localStartOffset = this.documentEditor.selection.getAbsolutePositionFromRelativePosition(this.documentEditor.selection.start);
        var selectionLength = this.documentEditor.selection.getAbsolutePositionFromRelativePosition(this.documentEditor.selection.end) - localStartOffset;
        if (!isNullOrUndefined(this.acknowledgmentPending)) {
            this.logMessage('Acknowledge transform:' + this.acknowledgmentPending[0].text + 'version:' + action.version);
            this.transform([this.acknowledgmentPending], action.operations);
        }
        if (this.pendingOps.length > 0) {
            this.logMessage('Pending transform:' + this.pendingOps.length + 'version:' + action.version);
        }
        this.transform(this.pendingOps, action.operations);
        this.applyRemoteOperation(action, localStartOffset, selectionLength);
        this.updateVersion(action.version);
        this.documentEditor.editor.isRemoteAction = false;
        if (this.documentEditor.editorHistory.canUndo()) {
            this.documentEditor.editorHistory.undoStack.length = 0;
        }
        if (this.documentEditor.editorHistory.canRedo()) {
            this.documentEditor.editorHistory.redoStack.length = 0;
        }
    };
    CollaborativeEditingHandler.prototype.transform = function (operation, remoteOperation) {
        for (var i = 0; i < remoteOperation.length; i++) {
            var remoteData = remoteOperation[i];
            if (operation.length > 0) {
                for (var j = 0; j < operation.length; j++) {
                    for (var k = 0; k < operation[j].length; k++) {
                        var localOperation = operation[j][k];
                        this.transformSelectionOperation(localOperation, remoteData);
                        var previousOffset = remoteData.offset;
                        this.transformOperation(localOperation, remoteData, remoteOperation);
                        this.logMessage('Transformed offset:' + (remoteData.offset - previousOffset));
                    }
                }
            }
        }
    };
    CollaborativeEditingHandler.prototype.skipAction = function (remoteOperation) {
        for (var i = 0; i < remoteOperation.length; i++) {
            var data = remoteOperation[i];
            data.length = 0;
            data.skipOperation = true;
        }
    };
    CollaborativeEditingHandler.prototype.applyRemoteOperation = function (action, offset, selectionLength) {
        for (var i = 0; i < action.operations.length; i++) {
            var markerData = action.operations[i].markerData;
            var trackingCurrentValue = this.documentEditor.enableTrackChanges;
            var currentUser = this.documentEditor.currentUser;
            if (!isNullOrUndefined(markerData) && !isNullOrUndefined(markerData.author)) {
                this.documentEditor.currentUser = markerData.author;
            }
            if (!isNullOrUndefined(markerData) && !isNullOrUndefined(markerData.isSkipTracking) && markerData.isSkipTracking && this.documentEditor.enableTrackChanges) {
                this.documentEditor.enableTrackChanges = false;
            }
            if (action.operations[i].skipOperation || (!isNullOrUndefined(action.operations[i].markerData) && action.operations[i].markerData.skipOperation)) {
                continue;
            }
            if (action.operations[i].action === 'Update') {
                if (action.operations[i].text === (CONTROL_CHARACTERS.Marker_Start.toString() + CONTROL_CHARACTERS.Marker_End.toString())) {
                    var ownerComment = undefined;
                    var commentToDelete = this.documentEditor.documentHelper.layout.getCommentById(this.documentEditor.documentHelper.comments, markerData.commentId);
                    var isDeleteComment = !isNullOrUndefined(commentToDelete);
                    if (!isNullOrUndefined(markerData.ownerCommentId) && markerData.isReply) {
                        ownerComment = this.documentEditor.documentHelper.layout.getCommentById(this.documentEditor.documentHelper.comments, markerData.ownerCommentId);
                        commentToDelete = this.documentEditor.documentHelper.layout.getCommentById(ownerComment.replyComments, markerData.commentId);
                        isDeleteComment = !isNullOrUndefined(commentToDelete);
                    }
                    if (!isNullOrUndefined(commentToDelete) && !(!isNullOrUndefined(markerData.done) && isNullOrUndefined(markerData.date))) {
                        if (commentToDelete.text !== markerData.text) {
                            var commentView = this.documentEditor.commentReviewPane.commentPane.comments.get(commentToDelete);
                            commentView.commentText.innerText = markerData.text;
                            commentToDelete.text = markerData.text;
                            continue;
                        }
                    }
                    if (isDeleteComment) {
                        if (!isNullOrUndefined(markerData.done) && isNullOrUndefined(markerData.date)) {
                            var comment = this.documentEditor.documentHelper.layout.getCommentById(this.documentEditor.documentHelper.comments, markerData.commentId);
                            if (markerData.done) {
                                this.documentEditor.editor.resolveComment(comment);
                            }
                            else {
                                this.documentEditor.editor.reopenComment(comment);
                            }
                            continue;
                        }
                        var commentView = this.documentEditor.commentReviewPane.commentPane.comments.get(!isNullOrUndefined(ownerComment) ? ownerComment : commentToDelete);
                        commentView.showDrawer();
                        this.documentEditor.editor.deleteCommentWidget(commentToDelete);
                        this.deletedComments.push(commentToDelete);
                        commentView.hideDrawer();
                    }
                    else {
                        var item = new CommentElementBox(markerData.date);
                        item.commentId = markerData.commentId;
                        var commentStart = this.getObjectByCommentId(this.commentsStart, item.commentId);
                        var commentEnd = this.getObjectByCommentId(this.commentsEnd, item.commentId);
                        this.documentEditor.editor.updateCommentElement(item, commentStart, commentEnd, markerData);
                        if (markerData.isReply) {
                            var ownerComment_1 = this.documentEditor.documentHelper.layout.getCommentById(this.documentEditor.documentHelper.comments, markerData.ownerCommentId);
                            item.ownerComment = ownerComment_1;
                            ownerComment_1.replyComments.splice(markerData.commentIndex, 0, item);
                            this.documentEditor.commentReviewPane.addReply(item, false, false);
                        }
                        else {
                            this.documentEditor.editor.addCommentWidget(item, true, true, false);
                            this.commentsStart.splice(this.commentsStart.indexOf(commentStart), 1);
                            this.commentsEnd.splice(this.commentsEnd.indexOf(commentEnd), 1);
                            var comment = this.documentEditor.commentReviewPane.commentPane.comments.get(item);
                            comment.postComment();
                        }
                    }
                }
                else if (!isNullOrUndefined(action.operations[i].styleData)) {
                    var styleData = JSON.parse(action.operations[i].styleData);
                    var styles = new WStyles();
                    this.documentEditor.parser.parseStyles(styleData, styles);
                    for (var i_1 = 0; i_1 < styles.length; i_1++) {
                        var style = styles.getItem(i_1);
                        var styleInCollection = this.documentEditor.documentHelper.styles.findByName(style.name);
                        if (!isNullOrUndefined(styleData[abstractListsProperty[1]])) {
                            this.documentEditor.parser.parseAbstractList(styleData, this.documentEditor.documentHelper.abstractLists);
                            if (!isNullOrUndefined(styleData[listsProperty[1]])) {
                                this.documentEditor.parser.parseList(styleData, this.documentEditor.documentHelper.lists);
                            }
                        }
                        if (!isNullOrUndefined(styleInCollection)) {
                            this.documentEditor.updateStyle(styleInCollection, style);
                            this.documentEditor.isShiftingEnabled = true;
                            this.documentEditor.editorModule.layoutWholeDocument();
                            this.documentEditor.isShiftingEnabled = false;
                        }
                        else {
                            this.documentEditor.documentHelper.styles.push(style);
                        }
                    }
                }
                continue;
            }
            var startOffset = this.getRelativePositionFromAbsolutePosition(action.operations[i].offset, false, false, false);
            var op2 = action.operations[i];
            var endOffset = startOffset;
            if (isNullOrUndefined(action.operations[i].action)) {
                this.documentSettings(action.operations[i]);
                continue;
            }
            if (action.operations[i].action === 'Delete' || action.operations[i].action === 'Format') {
                //Update endOffset
                endOffset = this.getRelativePositionFromAbsolutePosition(action.operations[i].offset + action.operations[i].length, false, false, false);
            }
            if (op2.action === 'Insert' && (op2.text !== CONTROL_CHARACTERS.Row && op2.text !== CONTROL_CHARACTERS.Cell) && (isNullOrUndefined(op2.markerData) || isNullOrUndefined(op2.markerData.isAcceptOrReject))) {
                this.documentEditor.selection.select(startOffset, endOffset);
            }
            else if (op2.action === 'Delete' && op2.text !== CONTROL_CHARACTERS.Cell && (isNullOrUndefined(op2.markerData) || isNullOrUndefined(op2.markerData.isAcceptOrReject))) {
                this.documentEditor.selection.select(startOffset, endOffset);
            }
            else if (op2.action === 'Format' && op2.text !== CONTROL_CHARACTERS.Cell && isNullOrUndefined(op2.tableFormat) && (isNullOrUndefined(op2.markerData) || isNullOrUndefined(op2.markerData.isAcceptOrReject))) {
                this.documentEditor.selection.select(startOffset, endOffset);
            }
            if (!isNullOrUndefined(op2.markerData)) {
                this.documentEditor.editor.revisionData = [];
                if (!isNullOrUndefined(op2.markerData.revisionForFootnoteEndnoteContent)) {
                    this.documentEditor.editor.revisionData.push(op2.markerData.revisionForFootnoteEndnoteContent);
                }
                if (!isNullOrUndefined(op2.markerData.revisionId)) {
                    this.documentEditor.editor.revisionData.push(op2.markerData);
                }
                if (!isNullOrUndefined(op2.markerData.splittedRevisions) && op2.markerData.splittedRevisions.length > 0) {
                    this.documentEditor.editor.revisionData = this.documentEditor.editor.revisionData.concat(op2.markerData.splittedRevisions);
                }
            }
            if (!isNullOrUndefined(op2.markerData) && !isNullOrUndefined(op2.markerData.isAcceptOrReject) && op2.markerData.isAcceptOrReject !== '') {
                var revision = this.documentEditor.editor.getRevision(op2.markerData.revisionId);
                if (op2.markerData.isAcceptOrReject === 'Accept') {
                    revision.accept();
                }
                else if (op2.markerData.isAcceptOrReject === 'Reject') {
                    revision.reject();
                }
                continue;
            }
            if (op2.action === 'Insert') {
                if (op2.type === 'Paste') {
                    this.documentEditor.editor.isPasteListUpdated = false;
                    this.documentEditor.editor.pasteContents(HelperMethods.getSfdtDocument(op2.pasteContent));
                }
                else if (op2.type === 'PasteToc') {
                    this.documentEditor.editor.isInsertingTOC = true;
                    this.documentEditor.editor.pasteContents(HelperMethods.getSfdtDocument(op2.pasteContent));
                    this.documentEditor.editor.isInsertingTOC = false;
                }
                else if (op2.text === CONTROL_CHARACTERS.Image.toString()) {
                    this.insertImage(op2.imageData);
                }
                else if (op2.text === CONTROL_CHARACTERS.Section_Break.toString() && op2.type === 'NewPage') {
                    this.documentEditor.editor.insertSectionBreak();
                }
                else if (op2.text === CONTROL_CHARACTERS.Section_Break.toString() && op2.type === 'Continuous') {
                    this.documentEditor.editor.insertSectionBreak(SectionBreakType.Continuous);
                }
                else if (markerData && (op2.text === CONTROL_CHARACTERS.Marker_Start || op2.text === CONTROL_CHARACTERS.Marker_End || op2.text === CONTROL_CHARACTERS.Field_Separator)) {
                    var element = void 0;
                    if (markerData.type && markerData.type === 'Bookmark') {
                        if (op2.text === CONTROL_CHARACTERS.Marker_Start) {
                            var bookmarks = this.documentEditor.editor.createBookmarkElements(markerData.bookmarkName);
                            element = bookmarks[0];
                            this.documentEditor.documentHelper.isBookmarkInserted = false;
                            this.documentEditor.editor.insertElementsInternal(this.documentEditor.selection.start, [element]);
                        }
                        else {
                            var bookmark = this.documentEditor.documentHelper.bookmarks.get(markerData.bookmarkName);
                            if (bookmark) {
                                element = bookmark.reference;
                                this.documentEditor.documentHelper.isBookmarkInserted = true;
                                this.documentEditor.editor.insertElementsInternal(this.documentEditor.selection.start, [element]);
                                this.documentEditor.selection.selectBookmark(markerData.bookmarkName);
                                bookmark.properties = this.documentEditor.selection.getBookmarkProperties(bookmark);
                                element.properties = this.documentEditor.selection.getBookmarkProperties(element);
                            }
                        }
                    }
                    else if (markerData.type && markerData.type === 'EditRange') {
                        var user = markerData.user;
                        var id = markerData.editRangeId;
                        if (op2.text === CONTROL_CHARACTERS.Marker_Start) {
                            element = this.documentEditor.editor.addEditElement(user, id);
                            element.columnFirst = parseInt(markerData.columnFirst);
                            element.columnLast = parseInt(markerData.columnLast);
                        }
                        else {
                            var editRanges = this.documentEditor.documentHelper.editRanges.get(user);
                            for (var _i = 0, editRanges_1 = editRanges; _i < editRanges_1.length; _i++) {
                                var editStart = editRanges_1[_i];
                                if (editStart.editRangeId === id) {
                                    element = editStart.editRangeEnd;
                                    break;
                                }
                            }
                        }
                        this.documentEditor.editor.insertElementsInternal(this.documentEditor.selection.start, [element]);
                    }
                    else if (markerData.type && markerData.type === 'Field') {
                        var type = op2.text === CONTROL_CHARACTERS.Marker_Start ? 0 : op2.text === CONTROL_CHARACTERS.Marker_End ? 1 : op2.text === CONTROL_CHARACTERS.Field_Separator ? 2 : undefined;
                        if (!isNullOrUndefined(type) && isNullOrUndefined(markerData.checkBoxValue)) {
                            var field = new FieldElementBox(type);
                            if (type === 0 && !isNullOrUndefined(markerData.formFieldData)) {
                                var formFieldData = this.documentEditor.editor.getFormFieldData(op2.type);
                                this.documentEditor.parser.parseFormFieldData(0, markerData.formFieldData, formFieldData);
                                field.formFieldData = formFieldData;
                            }
                            var characterFormat = new WCharacterFormat();
                            var data_1 = JSON.parse(op2.characterFormat);
                            this.documentEditor.parser.parseCharacterFormat(0, data_1, characterFormat);
                            field.characterFormat.copyFormat(characterFormat);
                            this.documentEditor.editor.initInsertInline(field);
                        }
                        else {
                            var inlineObj = this.documentEditor.selection.start.currentWidget.getInline(this.documentEditor.selection.start.offset, 0);
                            var inline = inlineObj.element;
                            if (inline instanceof FieldElementBox) {
                                this.documentEditor.editor.toggleCheckBoxFormField(inline, true, markerData.checkBoxValue);
                            }
                        }
                    }
                    else if (!isNullOrUndefined(markerData) && !isNullOrUndefined(markerData.commentId)) {
                        var commentType = op2.text === CONTROL_CHARACTERS.Marker_Start ? 0 : 1;
                        var deleteComment = this.documentEditor.documentHelper.layout.getCommentById(this.deletedComments, markerData.commentId);
                        var ownerDeleteComment = undefined;
                        if (isNullOrUndefined(deleteComment)) {
                            deleteComment = this.documentEditor.documentHelper.layout.getCommentById(this.documentEditor.documentHelper.comments, markerData.commentId);
                            if (isNullOrUndefined(deleteComment) && !isNullOrUndefined(markerData.ownerCommentId)) {
                                ownerDeleteComment = this.documentEditor.documentHelper.layout.getCommentById(this.documentEditor.documentHelper.comments, markerData.ownerCommentId);
                                deleteComment = this.documentEditor.documentHelper.layout.getCommentById(ownerDeleteComment.replyComments, markerData.commentId);
                            }
                        }
                        if (!isNullOrUndefined(deleteComment)) {
                            var item = new CommentCharacterElementBox(commentType);
                            item.commentId = markerData.commentId;
                            this.documentEditor.editor.insertElementsInternal(this.documentEditor.selection.start, [item]);
                            item.comment = deleteComment;
                            var index = this.documentEditor.selection.start.currentWidget.children.indexOf(item);
                            deleteComment.commentStart = this.documentEditor.selection.start.currentWidget.children[index];
                        }
                        else {
                            var item = new CommentCharacterElementBox(commentType);
                            item.commentId = markerData.commentId;
                            this.documentEditor.editor.insertElementsInternal(this.documentEditor.selection.start, [item]);
                            commentType === 0 ? this.commentsStart.push(item) : this.commentsEnd.push(item);
                        }
                    }
                    else if (!isNullOrUndefined(op2.markerData.type) && (op2.markerData.type === 'Footnote' || op2.markerData.type === 'Endnote')) {
                        if (op2.markerData.type === 'Footnote') {
                            this.documentEditor.editor.insertFootnote();
                        }
                        else if (op2.markerData.type === 'Endnote') {
                            this.documentEditor.editor.insertEndnote();
                        }
                    }
                }
                else if (markerData && !isNullOrUndefined(markerData.dropDownIndex) && op2.type === 'DropDown') {
                    var inlineObj = this.documentEditor.selection.start.currentWidget.getInline(this.documentEditor.selection.start.offset, 0);
                    var inline = inlineObj.element;
                    if (inline instanceof FieldElementBox) {
                        this.documentEditor.editor.updateFormField(inline, markerData.dropDownIndex, false);
                    }
                }
                else if (op2.text === CONTROL_CHARACTERS.Section_Break.toString() && op2.type === 'NewPage') {
                    this.documentEditor.editor.insertSectionBreak();
                }
                else if (op2.text === CONTROL_CHARACTERS.Section_Break.toString() && op2.type === 'Continuous') {
                    this.documentEditor.editor.insertSectionBreak(SectionBreakType.Continuous);
                }
                else if (op2.text === CONTROL_CHARACTERS.Table) {
                    i = action.operations.length;
                    this.buildTable(action.operations);
                }
                else if (op2.text === CONTROL_CHARACTERS.Row) {
                    i = action.operations.length;
                    if (isNullOrUndefined(op2.rowFormat)) {
                        action.operations.reverse();
                    }
                    this.buildRow(action.operations);
                }
                else if (op2.text === CONTROL_CHARACTERS.Cell) {
                    i = action.operations.length;
                    this.buildCell(action.operations);
                }
                else if (op2.text === CONTROL_CHARACTERS.PageBreak.toString()) {
                    this.documentEditor.editor.insertPageBreak();
                }
                else if (op2.text === CONTROL_CHARACTERS.ColumnBreak.toString()) {
                    this.documentEditor.editor.insertColumnBreak();
                }
                else {
                    if (op2.characterFormat) {
                        var characterFormat = new WCharacterFormat();
                        var data = JSON.parse(op2.characterFormat);
                        this.documentEditor.parser.parseCharacterFormat(0, data, characterFormat);
                        this.documentEditor.selection.characterFormat.copyFormat(characterFormat);
                    }
                    this.documentEditor.editor.insertText(op2.text);
                }
            }
            else if (op2.action === 'Delete') {
                // if (this.documentEditor.selection.isEmpty && this.documentEditor.selection.start.currentWidget.isLastLine()
                //     && this.documentEditor.selection.start.offset === this.documentEditor.selection.getLineLength(this.documentEditor.selection.start.currentWidget) + 1) {
                //     this.documentEditor.selection.start.offset--;
                //     this.documentEditor.selection.end.offset--;
                //     //Delete pargaraph marker
                //     this.documentEditor.editor.delete();
                // } else {
                if (op2.text === CONTROL_CHARACTERS.Marker_Start || op2.text === CONTROL_CHARACTERS.Marker_End) {
                    if (!isNullOrUndefined(markerData) && !isNullOrUndefined(markerData.commentId)) {
                        var deleteComment = this.documentEditor.documentHelper.layout.getCommentById(this.deletedComments, markerData.commentId);
                        var ownerDeleteComment = undefined;
                        if (isNullOrUndefined(deleteComment)) {
                            deleteComment = this.documentEditor.documentHelper.layout.getCommentById(this.documentEditor.documentHelper.comments, markerData.commentId);
                            if (isNullOrUndefined(deleteComment) && !isNullOrUndefined(markerData.ownerCommentId)) {
                                ownerDeleteComment = this.documentEditor.documentHelper.layout.getCommentById(this.documentEditor.documentHelper.comments, markerData.ownerCommentId);
                                deleteComment = this.documentEditor.documentHelper.layout.getCommentById(ownerDeleteComment.replyComments, markerData.commentId);
                            }
                        }
                        var selection = this.documentEditor.selection;
                        var commentType = op2.text === CONTROL_CHARACTERS.Marker_Start ? 0 : 1;
                        if (commentType === 1) {
                            var commentEnd = deleteComment.commentEnd;
                            if (commentEnd.indexInOwner !== -1) {
                                this.documentEditor.editor.removeAtOffset(selection.start.currentWidget, this.documentEditor.selection, selection.start.offset);
                            }
                        }
                        else {
                            var commentStart = deleteComment.commentStart;
                            if (commentStart.indexInOwner !== -1) {
                                this.documentEditor.editor.removeAtOffset(selection.start.currentWidget, this.documentEditor.selection, selection.start.offset);
                            }
                            commentStart.removeCommentMark();
                        }
                    }
                    else {
                        var selection = this.documentEditor.selection;
                        var offset_1 = selection.start.offset - 1;
                        this.documentEditor.editor.removeAtOffset(selection.start.currentWidget, this.documentEditor.selection, offset_1);
                    }
                }
                else if (op2.text === CONTROL_CHARACTERS.Table) {
                    this.documentEditor.editor.deleteTable();
                }
                else if (op2.text === CONTROL_CHARACTERS.Row) {
                    this.documentEditor.editor.deleteRow();
                }
                else if (op2.text === CONTROL_CHARACTERS.Cell) {
                    for (var j = 1; j < action.operations.length; j++) {
                        if (action.operations[j].action === 'Delete' && action.operations[j].text === CONTROL_CHARACTERS.Cell) {
                            i++;
                        }
                    }
                    this.buildDeleteCells(action.operations);
                }
                else {
                    this.documentEditor.editor.onBackSpace();
                }
                //}
            }
            else if (op2.action === 'Format') {
                if (!isNullOrUndefined(op2.markerData) && !isNullOrUndefined(op2.markerData.revisionId)) {
                    if (!isNullOrUndefined(op2.markerData.revisionType)) {
                        if (op2.markerData.revisionType === 'Deletion') {
                            if (op2.text === CONTROL_CHARACTERS.Row) {
                                var data_2 = this.getRelativePositionFromAbsolutePosition(op2.offset, false, true, false);
                                if (!isNullOrUndefined(data_2.rowWidget)) {
                                    var row = data_2.rowWidget;
                                    this.documentEditor.editor.trackRowDeletion(row);
                                    this.documentEditor.trackChangesPane.updateTrackChanges();
                                    continue;
                                }
                            }
                            this.documentEditor.editor.onBackSpace();
                        }
                    }
                }
                else if (op2.text === CONTROL_CHARACTERS.Row) {
                    var data_3 = this.getRelativePositionFromAbsolutePosition(op2.offset, false, true, false);
                    if (!isNullOrUndefined(data_3.rowWidget)) {
                        var table = data_3.rowWidget.ownerTable;
                        var rowData = JSON.parse(op2.rowFormat);
                        this.documentEditor.documentHelper.owner.parser.parseRowFormat(rowData, data_3.rowWidget.rowFormat, 0);
                        table.calculateGrid(false);
                        this.documentEditor.documentHelper.layout.reLayoutTable(table);
                    }
                }
                else if (op2.text === CONTROL_CHARACTERS.Cell) {
                    var data_4 = this.getRelativePositionFromAbsolutePosition(op2.offset, false, false, true);
                    if (!isNullOrUndefined(data_4.cellWidget)) {
                        var row = data_4.cellWidget.ownerRow;
                        var table = row.ownerTable;
                        if (!isNullOrUndefined(op2.tableFormat)) {
                            var tableData = JSON.parse(op2.tableFormat);
                            this.documentEditor.documentHelper.owner.parser.parseTableFormat(tableData, table.tableFormat, 0);
                        }
                        if (!isNullOrUndefined(op2.rowFormat)) {
                            var rowData = JSON.parse(op2.rowFormat);
                            this.documentEditor.documentHelper.owner.parser.parseRowFormat(rowData, row.rowFormat, 0);
                        }
                        var cellData = JSON.parse(op2.cellFormat);
                        this.documentEditor.documentHelper.owner.parser.parseCellFormat(cellData, data_4.cellWidget.cellFormat, 0);
                        table.calculateGrid(false);
                        this.documentEditor.documentHelper.layout.reLayoutTable(table);
                    }
                }
                else if (op2.text === CONTROL_CHARACTERS.Image) {
                    var inlineObj = this.documentEditor.selection.start.currentWidget.getInline(this.documentEditor.selection.start.offset, 0);
                    var inline = inlineObj.element;
                    if (inline instanceof ImageElementBox) {
                        this.documentEditor.editor.onImageFormat(inline, HelperMethods.convertPointToPixel(op2.imageData.width), HelperMethods.convertPointToPixel(op2.imageData.height), undefined);
                    }
                }
                else if (op2.type === 'ListFormat') {
                    var paragraphFormat = JSON.parse(op2.paragraphFormat);
                    var format = new WParagraphFormat(undefined);
                    this.documentEditor.parser.parseParagraphFormat(0, paragraphFormat, format);
                    this.updateList(op2, format);
                    var list = this.documentEditor.documentHelper.getListById(paragraphFormat.listFormat.nsid, true);
                    if (!isNullOrUndefined(list)) {
                        format.listFormat.listId = list.listId;
                        format.listFormat.list = list;
                    }
                    this.documentEditor.editor.onApplyParagraphFormat(op2.text, format.listFormat, false, false);
                }
                else if (op2.type === 'RestartNumbering') {
                    var nsid = this.updateList(op2);
                    var list = this.documentEditor.documentHelper.getListById(nsid, true);
                    this.documentEditor.editor.restartListAtInternal(this.documentEditor.selection, list.listId, list.nsid);
                }
                else if (op2.type === 'ContinueNumbering') {
                    var paragraphFormat = JSON.parse(op2.paragraphFormat);
                    var format = new WParagraphFormat(undefined);
                    this.documentEditor.parser.parseParagraphFormat(0, paragraphFormat, format);
                    var list = this.documentEditor.documentHelper.getListById(format.listFormat.nsid, true);
                    if (!isNullOrUndefined(list)) {
                        format.listFormat.listId = list.listId;
                        format.listFormat.list = list;
                    }
                    this.documentEditor.editor.applyContinueNumberingInternal(this.documentEditor.selection, format);
                }
                else if (!isNullOrUndefined(op2.characterFormat)) {
                    this.insertCharaterFormat(op2.type, op2.characterFormat);
                }
                else if (!isNullOrUndefined(op2.paragraphFormat)) {
                    this.insertParagraphFormat(op2.text, op2.paragraphFormat);
                }
                else if (!isNullOrUndefined(op2.tableFormat)) {
                    this.insertTableFormat(op2.type, op2.tableFormat, op2.offset);
                }
                else if (!isNullOrUndefined(op2.sectionFormat)) {
                    this.insertSectionFormat(op2.text, op2.sectionFormat);
                }
                else if (!isNullOrUndefined(op2.rowFormat)) {
                    this.insertRowFormat(op2.text, op2.rowFormat);
                }
                else if (!isNullOrUndefined(op2.cellFormat)) {
                    this.insertCellFormat(op2.cellFormat);
                }
            }
            this.documentEditor.editor.revisionData = [];
            this.documentEditor.enableTrackChanges = trackingCurrentValue;
            this.documentEditor.currentUser = currentUser;
            var newOffset = this.documentEditor.selection.startOffset;
            //op2.offset = newOffset;
            this.updateRemoteSelection(action, this.documentEditor.selection.getAbsolutePositionFromRelativePosition(newOffset));
            var tranformedOffset = this.transformSection(op2.action, op2, offset)[1];
            //TODO: Need to handle backward selection.
            //TODO: Need to optimize the code. Need to transform selection end length based on remove content
            var tranformedEndOffset = this.transformSection(op2.action, op2, offset + selectionLength)[1];
            this.documentEditor.selection.select(this.getRelativePositionFromAbsolutePosition(tranformedOffset, false, false, false), this.getRelativePositionFromAbsolutePosition(tranformedEndOffset, false, false, false));
            this.transformRemoteCursor(action.connectionId, op2, op2.offset);
            if (!isNullOrUndefined(this.documentEditor.search) && !isNullOrUndefined(this.documentEditor.optionsPaneModule) && this.documentEditor.search.searchResults.length > 0 && this.documentEditor.optionsPaneModule.isOptionsPaneShow) {
                this.documentEditor.optionsPaneModule.searchIconClickInternal();
            }
        }
    };
    CollaborativeEditingHandler.prototype.updateList = function (operation, format) {
        var nsid = -1;
        if (operation.listData) {
            var listData = JSON.parse(operation.listData);
            if (listData.hasOwnProperty('optimizeSfdt')) {
                this.documentEditor.parser.keywordIndex = listData.optimizeSfdt ? 1 : 0;
            }
            if (!isNullOrUndefined(format)) {
                var list = this.documentEditor.documentHelper.getListById(format.listFormat.nsid, true);
                if (isNullOrUndefined(list)) {
                    this.updateListCollection(listData, this.documentEditor.parser.keywordIndex);
                }
                else {
                    var abstractLists = [];
                    this.documentEditor.parser.parseAbstractList(listData, abstractLists);
                    if (!isNullOrUndefined(list.abstractList)) {
                        if (list.abstractList.levels.length < format.listFormat.listLevelNumber) {
                            list.abstractList.levels = [];
                            for (var i = 0; i < abstractLists[0].levels.length; i++) {
                                list.abstractList.levels.push(abstractLists[0].levels[i]);
                            }
                        }
                    }
                }
            }
            else {
                if (listData.hasOwnProperty(nsidProperty)) {
                    nsid = listData[nsidProperty];
                }
                this.updateListCollection(listData, this.documentEditor.parser.keywordIndex);
            }
        }
        return nsid;
    };
    CollaborativeEditingHandler.prototype.updateListCollection = function (listData, keywordIndex) {
        var uniqueListId = this.documentEditor.editor.getUniqueListOrAbstractListId(true);
        var uniqueAbsLstId = this.documentEditor.editor.getUniqueListOrAbstractListId(false);
        var _loop_1 = function (k) {
            var list = listData[listsProperty[keywordIndex]][k];
            var abstractList = listData[abstractListsProperty[keywordIndex]].filter(function (obj) {
                return obj[abstractListIdProperty[keywordIndex]] === list[abstractListIdProperty[keywordIndex]];
            })[0];
            if (!isNullOrUndefined(abstractList)) {
                abstractList[abstractListIdProperty[keywordIndex]] = uniqueAbsLstId;
                list[listIdProperty[keywordIndex]] = uniqueListId;
                list[abstractListIdProperty[keywordIndex]] = uniqueAbsLstId;
                uniqueListId++;
                uniqueAbsLstId++;
            }
        };
        for (var k = 0; k < listData[listsProperty[keywordIndex]].length; k++) {
            _loop_1(k);
        }
        this.documentEditor.parser.parseAbstractList(listData, this.documentEditor.documentHelper.abstractLists);
        this.documentEditor.parser.parseList(listData, this.documentEditor.documentHelper.lists);
    };
    CollaborativeEditingHandler.prototype.getObjectByCommentId = function (collection, commentId) {
        for (var _i = 0, collection_1 = collection; _i < collection_1.length; _i++) {
            var obj = collection_1[_i];
            if (obj.commentId === commentId) {
                return obj;
            }
        }
        return undefined;
    };
    CollaborativeEditingHandler.prototype.transformOperation = function (operation1, operation2, action) {
        if (operation1.action === 'Insert' && (operation2.action === 'Insert' || operation2.action === 'Format')) {
            if (operation1.offset < operation2.offset) {
                operation2.offset = operation2.offset + operation1.length;
                return [operation1, operation2];
            }
            else if (operation1.offset >= operation2.offset && operation2.action !== 'Format') {
                operation1.offset = operation1.offset + operation2.length;
                return [operation1, operation2,];
            }
            // else {
            //     return [
            //         operation1,
            //         {
            //             action: 'Insert',
            //             offset: operation1.offset,
            //             text: operation2.text,
            //         },
            //     ];
            // }
        }
        else if (operation1.action === 'Delete' && (operation2.action === 'Delete' || operation2.action === 'Format')) {
            if (operation1.offset < operation2.offset) {
                operation2.offset = operation2.offset - operation1.length;
                return [operation1, operation2];
            }
            else if (operation1.offset > operation2.offset && operation2.action !== 'Format') {
                operation1.offset = operation1.offset - operation2.length;
                return [operation1, operation2,];
            }
        }
        else if (operation1.action === 'Insert' && (operation2.action === 'Delete' || operation2.action === 'Format')) {
            if (operation1.offset <= operation2.offset) {
                operation2.offset = operation2.offset + operation1.length;
                return [operation1, operation2];
            }
            else if (operation1.offset >= operation2.offset + operation2.length && operation2.action !== 'Format') {
                operation1.offset = operation1.offset - operation2.length;
                return [operation1, operation2,];
            }
            // Local selection fully encompasses the conflicting selection
            else if (operation1.offset > operation2.offset && operation1.offset < (operation2.offset + operation2.length)) {
                operation2.length += operation1.length;
            }
            // else {
            //     return [
            //         // {
            //         //     type: 'Insert',
            //         //     position: operation2.position,
            //         //     text: operation1.text.slice(0, operation2.position - operation1.position) +
            //         //         operation1.text.slice(operation2.position + operation2.length - operation1.position),
            //         // },
            //         // {
            //         //     type: 'Delete',
            //         //     position: operation2.position,
            //         //     length: operation1.length - (operation2.position - operation1.position) - operation2.length,
            //         // },
            //     ];
            // }
        }
        else if (operation1.action === 'Delete' && (operation2.action === 'Insert' || operation2.action === 'Format')) {
            if (operation1.offset <= operation2.offset && (operation1.offset + operation1.length) <= operation2.offset) {
                operation2.offset = operation2.offset - operation1.length;
            }
            else if (operation1.offset < operation2.offset && (operation1.offset + operation1.length) >= (operation2.offset + operation2.length)) {
                if (!isNullOrUndefined(operation2.markerData) && !isNullOrUndefined(operation2.markerData.type) && operation2.markerData.type !== 'Field' && (operation2.text === CONTROL_CHARACTERS.Marker_End || operation2.text === CONTROL_CHARACTERS.Marker_Start)) {
                    if (!isNullOrUndefined(operation2.markerData.commentId) && operation2.text === CONTROL_CHARACTERS.Marker_End) {
                        this.skipAction(action);
                        return [operation1, operation2];
                    }
                    var conflictLenth = operation2.offset - operation1.offset;
                    operation2.offset -= conflictLenth;
                }
                else {
                    //Skip insert operation
                    operation2.length = 0;
                    operation2.skipOperation = true;
                    if (!isNullOrUndefined(operation2.markerData) && !isNullOrUndefined(operation2.markerData.type) && operation2.markerData.type === 'Field' && (operation2.text === CONTROL_CHARACTERS.Marker_Start || operation2.text === CONTROL_CHARACTERS.Marker_End)) {
                        this.skipAction(action);
                    }
                }
            }
            else if (operation1.offset > operation2.offset && operation2.action !== 'Format') {
                operation1.offset = operation1.offset + operation2.length;
            }
        }
        // else {
        //     throw new Error(`Invalid operation types: ${operation1.action}, ${operation2.action}`);
        // }
        return [operation1, operation2];
    };
    CollaborativeEditingHandler.prototype.transformSection = function (action, operation1, operation2) {
        if (action === 'Insert') {
            if (operation1.offset <= operation2) {
                return [operation1.offset, operation2 + operation1.length];
            }
            // else if (operation1.offset > operation2.offset) {
            //     return [
            //         operation1.offset + operation2.length,
            //         operation2.offset,
            //     ];
            // }
        }
        else if (action === 'Delete') {
            if (operation1.offset <= operation2) {
                return [operation1.offset, operation2 - operation1.length];
            }
        }
        return [operation1.offset, operation2];
    };
    CollaborativeEditingHandler.prototype.transformRemoteCursor = function (connectionId, operation, offset) {
        var keys = Object.keys(this.userMap);
        //For loop to iterate over the keys
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key === connectionId) {
                continue;
            }
            var remoteOffset = this.userMap[key].offset;
            var tranformedOffset = this.transformSection(operation.action, operation, remoteOffset)[1];
            this.userMap[key].offset = tranformedOffset;
            this.updateCaretPositionInteral(this.userMap[key].caret, tranformedOffset);
        }
    };
    CollaborativeEditingHandler.prototype.updateRemoteSelection = function (data, removeOffset) {
        if (data.connectionId) {
            var color = '';
            var caret = void 0;
            if (this.userMap[data.connectionId] !== undefined) {
                color = this.userMap[data.connectionId].color;
                caret = this.userMap[data.connectionId].caret;
            }
            else {
                color = this.getColorForMember(Math.random() * 100);
                caret = createElement('div', { className: 'e-de-blink-cursor', styles: ('position:absolute;border-left: 2px solid ' + color) });
                this.userMap[data.connectionId] = new CaretInfo(color, caret, removeOffset, data.currentUser);
            }
            this.userMap[data.connectionId].offset = removeOffset;
            this.updateCaretPositionInteral(caret, removeOffset);
        }
    };
    CollaborativeEditingHandler.prototype.removeCarets = function (connectionId) {
        if (this.userMap[connectionId] !== undefined) {
            this.userMap[connectionId].caret.remove();
            delete this.userMap[connectionId];
        }
    };
    CollaborativeEditingHandler.prototype.getColorForMember = function (randonNumber) {
        var colorValue = randonNumber % 20;
        return "hsl(" + (colorValue * 360 / 7) % 360 + ", 100%, 35%)";
    };
    CollaborativeEditingHandler.prototype.updateCaretPositionInteral = function (caret, start) {
        var zoomFactor = this.documentEditor.zoomFactor;
        var selection = this.documentEditor.selection;
        var startPos = selection.getTextPosBasedOnLogicalIndex(this.getRelativePositionFromAbsolutePosition(start, false, false, false));
        //let endPos: TextPosition = selection.getTextPosBasedOnLogicalIndex(end);
        var caretPosition = startPos.location;
        //if (startPos.isInSameParagraph(endPos)) {
        caret.style.display = 'block';
        if (!caret.parentElement) {
            this.documentEditor.documentHelper.viewerContainer.appendChild(caret);
        }
        var page = selection.getSelectionPage(startPos);
        if (page) {
            caret.style.left = page.boundingRectangle.x + (Math.round(caretPosition.x) * zoomFactor) + 'px';
            var caretInfo = selection.updateCaretSize(startPos);
            var topMargin = caretInfo.topMargin;
            caret.style.height = caretInfo.height + 'px';
            var pageTop = selection.getPageTop(page);
            caret.style.top = pageTop + (Math.round(caretPosition.y + topMargin) * zoomFactor) + 'px';
            if (selection.characterFormat.baselineAlignment === 'Subscript') {
                caret.style.top = parseFloat(caret.style.top) + (parseFloat(caret.style.height) / 2) + 'px';
            }
        }
    };
    CollaborativeEditingHandler.prototype.getBlockPosition = function (offset, currentLength, block, completed, isTableInserted, isRowInserted, isCellInserted) {
        var paragraph;
        if (block instanceof ParagraphWidget) {
            var absoluteData = this.getBlockTotalLength(offset, currentLength, block, completed, isTableInserted, isRowInserted, isCellInserted);
            // length = block.getTotalLength() + 1;
            // paragraph = block;
            if (completed.done) {
                completed.done = true;
                return absoluteData;
            }
            else {
                //Add paragraph mark length
                currentLength = absoluteData.currentLength;
                paragraph = absoluteData.paragraph;
            }
        }
        else if (block instanceof TableWidget) {
            // Table start mark length
            offset -= 1;
            if (offset === currentLength) {
                if (isTableInserted) {
                    completed.done = true;
                    return { 'offset': offset, 'currentLength': currentLength, 'paragraph': paragraph, 'tableWidget': block };
                }
            }
            var row = block.firstChild;
            while (row) {
                // Row mark length
                offset -= 1;
                if (offset === currentLength) {
                    if (isRowInserted) {
                        completed.done = true;
                        var index = row.index;
                        return { 'offset': offset, 'currentLength': currentLength, 'paragraph': paragraph, 'rowOrCellIndex': index, 'rowWidget': row };
                    }
                    else if (isCellInserted) {
                        completed.done = true;
                        var cellWidget = paragraph.associatedCell;
                        var index = cellWidget.cellIndex + 1;
                        return { 'offset': offset, 'currentLength': currentLength, 'paragraph': paragraph, 'rowOrCellIndex': index, 'cellWidget': cellWidget };
                    }
                }
                var cell = row.firstChild;
                while (cell) {
                    // Cell mark length
                    offset -= 1;
                    if (offset === currentLength) {
                        if (isCellInserted) {
                            completed.done = true;
                            var index = cell.cellIndex;
                            return { 'offset': offset, 'currentLength': currentLength, 'paragraph': paragraph, 'rowOrCellIndex': index, 'cellWidget': cell };
                        }
                    }
                    var childBlock = cell.firstChild;
                    while (childBlock) {
                        var data = this.getBlockPosition(offset, currentLength, childBlock, completed, isTableInserted, isRowInserted, isCellInserted);
                        if (completed.done) {
                            if (isRowInserted) {
                                completed.done = true;
                                var rowWidget = cell.ownerRow;
                                var index = rowWidget.index + 1;
                                return { 'offset': offset, 'currentLength': currentLength, 'paragraph': paragraph, 'rowOrCellIndex': index, 'rowWidget': rowWidget };
                            }
                            else if (isCellInserted) {
                                completed.done = true;
                                var cellWidget = cell;
                                var index = cellWidget.cellIndex + 1;
                                return { 'offset': offset, 'currentLength': currentLength, 'paragraph': paragraph, 'rowOrCellIndex': index, 'cellWidget': cellWidget };
                            }
                            else {
                                return data;
                            }
                        }
                        else {
                            offset = data.offset;
                            currentLength = data.currentLength;
                            paragraph = data.paragraph;
                        }
                        childBlock = childBlock.getSplitWidgets().pop().nextRenderedWidget;
                    }
                    cell = cell.nextWidget;
                }
                row = row.getSplitWidgets().pop().nextRenderedWidget;
            }
        }
        return { 'offset': offset, 'currentLength': currentLength, 'paragraph': paragraph };
    };
    CollaborativeEditingHandler.prototype.getBlockTotalLength = function (offset, currentLength, block, completed, isTableInserted, isRowInserted, isCellInserted) {
        var splittedWidget = block.getSplitWidgets();
        //Paragraph start offset
        var paragraphStartLength = 1;
        var length = 0;
        if (currentLength + paragraphStartLength >= offset) {
            completed.done = true;
            return { 'offset': offset - 1, 'currentLength': currentLength, 'paragraph': block };
        }
        var childBlockLength = 0;
        for (var i = 0; i < splittedWidget.length; i++) {
            for (var j = 0; j < splittedWidget[i].childWidgets.length; j++) {
                var line = splittedWidget[i].childWidgets[j];
                for (var k = 0; k < line.children.length; k++) {
                    var element = line.children[k];
                    if (element instanceof ListTextElementBox) {
                        continue;
                    }
                    if (element instanceof ShapeElementBox || element instanceof FootnoteElementBox) {
                        var absoluteData = void 0;
                        if (element instanceof ShapeElementBox) {
                            if (element.textFrame.childWidgets.length > 0) {
                                absoluteData = this.getBlockPosition(offset, currentLength + childBlockLength + length + paragraphStartLength, element.textFrame.childWidgets[0], completed, isTableInserted, isRowInserted, isCellInserted);
                            }
                        }
                        else {
                            var currentLengthValue = currentLength + childBlockLength + length + paragraphStartLength;
                            for (var m = 0; m < element.bodyWidget.childWidgets.length && !completed.done; m++) {
                                absoluteData = this.getBlockPosition(offset, currentLengthValue, element.bodyWidget.childWidgets[m], completed, isTableInserted, isRowInserted, isCellInserted);
                                currentLengthValue = absoluteData.currentLength;
                            }
                        }
                        offset = absoluteData.offset;
                        childBlockLength += (absoluteData.currentLength - (currentLength + length + paragraphStartLength + childBlockLength));
                        if (completed.done) {
                            currentLength = absoluteData.currentLength;
                            return absoluteData;
                        }
                    }
                    length += element.length;
                    if (currentLength + childBlockLength + length + paragraphStartLength >= offset) {
                        completed.done = true;
                        return { 'offset': offset - 1, 'currentLength': currentLength + childBlockLength, 'paragraph': block };
                    }
                }
            }
        }
        currentLength += (length + childBlockLength + paragraphStartLength);
        return { 'offset': offset, 'currentLength': currentLength, 'paragraph': block };
    };
    CollaborativeEditingHandler.prototype.getRelativePositionFromAbsolutePosition = function (offset, isTableInserted, isRowInserted, isCellInserted) {
        var documentEditor = this.documentEditor;
        var block = this.documentEditor.documentHelper.pages[0].bodyWidgets[0].childWidgets[0];
        var currentLength = 0;
        var positionInfo = { done: false };
        var blockObj = this.getBlockByIndex(block, offset, currentLength, positionInfo, isTableInserted, isRowInserted, isCellInserted);
        if (positionInfo.done) {
            var paragraphInfo = {
                paragraph: blockObj.paragraph,
                offset: blockObj.offset - blockObj.currentLength,
            };
            if (isTableInserted || isRowInserted || isCellInserted) {
                return blockObj;
            }
            else {
                return documentEditor.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
            }
        }
        var blockObj1 = this.getBlockIndexFromHeaderFooter(blockObj.offset, blockObj.currentLength, positionInfo, isTableInserted, isRowInserted, isCellInserted);
        if (positionInfo.done) {
            var paraOffset = blockObj.offset - blockObj.currentLength;
            if (paraOffset < 0) {
                paraOffset = 0;
            }
            var paragraphInfo = {
                paragraph: blockObj.paragraph,
                offset: paraOffset,
            };
            if (isTableInserted || isRowInserted || isCellInserted) {
                return blockObj1;
            }
            else {
                return documentEditor.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
            }
        }
        return '';
    };
    CollaborativeEditingHandler.prototype.getBlockIndexFromHeaderFooter = function (offset, currentLength, positionInfo, isTableInserted, isRowInserted, isCellInserted) {
        //Iterate header/footer content;
        var blockObj;
        var headersFooters = this.documentEditor.documentHelper.headersFooters;
        for (var _i = 0, headersFooters_1 = headersFooters; _i < headersFooters_1.length; _i++) {
            var headerFooter = headersFooters_1[_i];
            for (var i = 0; i < 6; i++) {
                var currentHeaderFooter = headerFooter[i];
                if (currentHeaderFooter) {
                    blockObj = this.getBlockByIndex(currentHeaderFooter.childWidgets[0], offset, currentLength, positionInfo, isTableInserted, isRowInserted, isCellInserted);
                    currentLength = blockObj.currentLength;
                    if (positionInfo.done) {
                        return blockObj;
                    }
                }
                else {
                    //Insert new header footer and paragraph to existing collection.
                    currentLength++;
                    blockObj.currentLength = currentLength;
                }
            }
        }
        return blockObj;
    };
    CollaborativeEditingHandler.prototype.getBlockByIndex = function (block, offset, currentLength, positionInfo, isTableInserted, isRowInserted, isCellInserted) {
        var blockObj;
        do {
            blockObj = this.getBlockPosition(offset, currentLength, block, positionInfo, isTableInserted, isRowInserted, isCellInserted);
            currentLength = blockObj.currentLength;
            offset = blockObj.offset;
            if (positionInfo.done) {
                return blockObj;
            }
            block = block.getSplitWidgets().pop().nextRenderedWidget;
        } while (block);
        return blockObj;
    };
    CollaborativeEditingHandler.prototype.insertImage = function (imageData) {
        if (isNullOrUndefined(imageData.metaString)) {
            this.documentEditor.editor.insertImageInternal(imageData.imageString, true, HelperMethods.convertPointToPixel(imageData.width), HelperMethods.convertPointToPixel(imageData.height));
        }
        else {
            this.documentEditor.editor.isImageInsert = true;
            this.documentEditor.editor.insertImageInternal(imageData.metaString, true, HelperMethods.convertPointToPixel(imageData.width), HelperMethods.convertPointToPixel(imageData.height));
        }
    };
    CollaborativeEditingHandler.prototype.buildTable = function (operations) {
        var rows = 0;
        var columns = 0;
        for (var i = 0; i < operations.length; i++) {
            if (operations[i].text === CONTROL_CHARACTERS.Row) {
                if (!isNullOrUndefined(operations[i].markerData)) {
                    this.documentEditor.editor.revisionData.push(operations[i].markerData);
                }
                rows++;
            }
        }
        for (var i = 0; i < operations.length; i++) {
            if (operations[i].text === CONTROL_CHARACTERS.Cell) {
                columns++;
            }
            if (operations[i].text !== CONTROL_CHARACTERS.Table && (isNullOrUndefined(operations[i + 1]) || operations[i + 1].text === CONTROL_CHARACTERS.Row)) {
                break;
            }
        }
        this.documentEditor.editor.insertTable(rows, columns);
        this.documentEditor.editor.revisionData = [];
    };
    CollaborativeEditingHandler.prototype.buildRow = function (operations) {
        var rowData;
        var cellDatas = [];
        var paragraphDatas = [];
        var characterDatas = [];
        var cellCount = 0;
        var insertRow = 0;
        var data = this.getRelativePositionFromAbsolutePosition(operations[0].offset, false, true, false);
        var tableWidget = data.rowWidget.ownerTable.combineWidget(this.documentEditor.viewer);
        if (!isNullOrUndefined(operations[0].markerData)) {
            if (isNullOrUndefined(operations[0].rowFormat)) {
                var row = data.rowWidget;
                if (row.rowFormat.revisions.length > 0) {
                    var revision = row.rowFormat.revisions[0];
                    revision.accept();
                    return;
                }
            }
        }
        for (var i = 0; i < operations.length; i++) {
            var operation = operations[i];
            if (operation.text === CONTROL_CHARACTERS.Cell) {
                cellCount++;
                cellDatas.push(JSON.parse(operation.cellFormat));
                paragraphDatas.push(JSON.parse(operation.paragraphFormat));
                characterDatas.push(JSON.parse(operation.characterFormat));
            }
            if (isNullOrUndefined(operations[i + 1]) || operations[i + 1].text === CONTROL_CHARACTERS.Row) {
                break;
            }
        }
        for (var i = 0; i < operations.length; i++) {
            if (operations[i].text === CONTROL_CHARACTERS.Row) {
                if (!isNullOrUndefined(operations[i].markerData)) {
                    this.documentEditor.editor.revisionData.push(operations[i].markerData);
                }
                insertRow++;
                rowData = JSON.parse(operations[i].rowFormat);
            }
        }
        this.documentEditor.editor.rowInsertionForCE(data.rowOrCellIndex, cellCount, insertRow, tableWidget, rowData, cellDatas, paragraphDatas, characterDatas);
        cellDatas = [];
        paragraphDatas = [];
        characterDatas = [];
        this.documentEditor.editor.revisionData = [];
    };
    CollaborativeEditingHandler.prototype.buildCell = function (operations) {
        var newCell;
        var rowWidget;
        var startParagraph;
        var cellLength = 0;
        for (var i = operations.length - 1; i >= 0; i--) {
            var operation = operations[i];
            if (operation.skipOperation && operation.length > 0) {
                continue;
            }
            var data = this.getRelativePositionFromAbsolutePosition(operation.offset + cellLength, false, false, true);
            if (operation.length > 0) {
                rowWidget = data.cellWidget.ownerRow;
                newCell = this.documentEditor.editor.cellInsertionForCE(data.rowOrCellIndex, rowWidget, JSON.parse(operation.cellFormat), JSON.parse(operation.paragraphFormat), JSON.parse(operation.characterFormat));
                if (isNullOrUndefined(startParagraph)) {
                    startParagraph = this.documentEditor.selection.getFirstParagraph(newCell);
                }
                cellLength += 2;
            }
            else {
                this.documentEditor.documentHelper.owner.parser.parseCellFormat(JSON.parse(operation.cellFormat), data.cellWidget.cellFormat, 0);
            }
        }
        var ownerTable = rowWidget.ownerTable.combineWidget(this.documentEditor.viewer);
        ownerTable.calculateGrid(true);
        this.documentEditor.documentHelper.layout.reLayoutTable(ownerTable);
        this.documentEditor.selection.start.setPosition(startParagraph.firstChild, true);
        this.documentEditor.selection.end.setPosition(this.documentEditor.selection.getLastParagraph(newCell).firstChild, false);
        this.documentEditor.editor.reLayout(this.documentEditor.selection);
    };
    CollaborativeEditingHandler.prototype.buildDeleteCells = function (operations) {
        var deleteCells = [];
        for (var i = operations.length - 1; i >= 0; i--) {
            var operation = operations[i];
            if (operation.skipOperation) {
                continue;
            }
            if (operation.action === 'Delete' && operation.text === CONTROL_CHARACTERS.Cell) {
                var data = this.getRelativePositionFromAbsolutePosition(operation.offset, false, false, true);
                deleteCells.push(data.cellWidget);
            }
        }
        var table = deleteCells[0].ownerTable.combineWidget(this.documentEditor.viewer);
        var paragraph = undefined;
        if (deleteCells[deleteCells.length - 1].nextWidget) {
            var nextCell = deleteCells[deleteCells.length - 1].nextWidget;
            paragraph = this.documentEditor.selection.getFirstParagraph(nextCell);
        }
        else if (deleteCells[0].previousWidget) {
            var previousCell = deleteCells[0].previousWidget;
            paragraph = this.documentEditor.selection.getFirstParagraph(previousCell);
        }
        this.documentEditor.editor.onDeleteColumn(table, deleteCells, paragraph, undefined);
    };
    CollaborativeEditingHandler.prototype.transformSelectionOperation = function (operation, conflictingOperation) {
        if (operation.action === 'Delete' && conflictingOperation.action === 'Delete') {
            var previousStart = conflictingOperation.offset;
            var conflictingSelection = conflictingOperation;
            // Case 1: No overlap, no conflict
            if ((operation.offset + operation.length) <= conflictingSelection.offset || operation.offset >= (conflictingSelection.offset + conflictingSelection.length)) {
                return;
            }
            // Case 2: Local selection is completely within the conflicting selection
            if (operation.offset >= conflictingSelection.offset && (operation.offset + operation.length) <= (conflictingSelection.offset + conflictingSelection.length)) {
                conflictingOperation.offset = conflictingOperation.offset;
                conflictingOperation.length -= operation.length;
                if (conflictingOperation.length <= 0) {
                    conflictingOperation.skipOperation = true;
                }
                return;
            }
            // Case 3: Local selection overlaps from the left side
            if (operation.offset < conflictingSelection.offset && (operation.offset + operation.length) <= (conflictingSelection.offset + conflictingSelection.length)) {
                conflictingOperation.offset = operation.offset + operation.length;
                conflictingOperation.length -= conflictingOperation.offset - previousStart;
                //return transformedOperation;
                return;
            }
            // Case 4: Local selection overlaps from the right side
            if (operation.offset >= conflictingSelection.offset && (operation.offset + operation.length) > (conflictingSelection.offset + conflictingSelection.length)) {
                conflictingOperation.length -= (conflictingOperation.offset + conflictingOperation.length) - operation.offset;
                return;
            }
            // Case 5: Local selection fully encompasses the conflicting selection
            if (operation.offset < conflictingSelection.offset && (operation.offset + operation.length) > (conflictingSelection.offset + conflictingSelection.length)) {
                conflictingSelection.offset = operation.offset;
                conflictingSelection.length = 0;
                conflictingOperation.skipOperation = true;
                return;
            }
        }
    };
    CollaborativeEditingHandler.prototype.documentSettings = function (operation) {
        this.documentEditor.skipSettingsOps = true;
        switch (operation.text) {
            case 'enableTrackChanges':
                this.documentEditor.enableTrackChanges = operation.enableTrackChanges;
                break;
            case 'protection':
                this.documentEditor.documentHelper.restrictEditingPane.showHideRestrictPane(true);
                if (!isNullOrUndefined(operation.protectionData.saltValue)) {
                    if (operation.protectionData.hashValue === '' && operation.protectionData.saltValue === '') {
                        this.documentEditor.editor.protectDocument(operation.protectionData.protectionType);
                    }
                    else {
                        this.documentEditor.editor.enforceProtectionAssign(operation.protectionData.saltValue, operation.protectionData.hashValue, operation.protectionData.protectionType);
                    }
                }
                else {
                    if (isNullOrUndefined(operation.protectionData.hashValue)) {
                        this.documentEditor.editor.unProtectDocument();
                    }
                    else {
                        this.documentEditor.editor.validateHashValue(operation.protectionData.hashValue);
                    }
                }
                break;
        }
    };
    CollaborativeEditingHandler.prototype.checkAndRetriveChangesFromServer = function () {
        var _this = this;
        if (!this.isSyncServerChanges) {
            var action = {
                version: this.version,
                connectionId: this.connectionId,
                fileName: this.roomName,
                timeStamp: HelperMethods.getUtcDate()
            };
            var httpRequest = new XMLHttpRequest();
            httpRequest.open('Post', this.serviceUrl + 'api/CollaborativeEditing/GetActionsFromServer', true);
            httpRequest.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
            httpRequest.onreadystatechange = function () {
                if (httpRequest.readyState === 4) {
                    if (httpRequest.status === 200 || httpRequest.status === 304) {
                        _this.applyChangesFromServer(httpRequest.responseText);
                    }
                    else {
                        alert('Fail to load the document');
                    }
                }
            };
            httpRequest.send(JSON.stringify(action));
            this.isSyncServerChanges = true;
        }
    };
    CollaborativeEditingHandler.prototype.applyChangesFromServer = function (data) {
        var dataObject = JSON.parse(data);
        if (dataObject.length > 0) {
            for (var i = 0; i < dataObject.length; i++) {
                var data_5 = dataObject[i];
                if (data_5.connectionId === this.connectionId) {
                    this.acknowledgementReceived();
                }
                else {
                    this.handleRemoteOperation(data_5);
                }
                this.updateVersion(data_5.version);
                this.logMessage('Server sync ack:' + data_5.version);
            }
            this.updateVersion(dataObject[dataObject.length - 1].version);
        }
        this.isSyncServerChanges = false;
        if (!this.isAcknowledgePending()) {
            this.acknowledgementReceived();
        }
        this.sendLocalOperation();
    };
    CollaborativeEditingHandler.prototype.insertCharaterFormat = function (type, characterData) {
        var format = new WCharacterFormat(undefined);
        var characterFormat = JSON.parse(characterData);
        var keys = Object.keys(characterFormat);
        this.documentEditor.documentHelper.owner.parser.parseCharacterFormat(0, characterFormat, format);
        if (keys.length > 1) {
            this.documentEditor.documentHelper.owner.fontDialogModule.onCharacterFormat(this.documentEditor.selection, format);
            this.documentEditor.editor.onApplyCharacterFormat('CharacterFormat', format);
        }
        else if (keys.length === 1) {
            if (keys.indexOf('styleName') !== -1) {
                this.documentEditor.editor.applyStyle(characterFormat.styleName, true);
            }
            else if (keys.indexOf('allCaps') !== -1) {
                this.documentEditor.editor.changeCase('Uppercase');
            }
            else {
                if (type === 'increment' || type === 'decrement') {
                    this.documentEditor.editor.onApplyCharacterFormat(keys[0], type, true);
                }
                else {
                    this.documentEditor.editor.onApplyCharacterFormat(keys[0], characterFormat[keys[0]]);
                }
            }
        }
        else {
            this.documentEditor.editor.clearFormatting();
        }
    };
    CollaborativeEditingHandler.prototype.insertParagraphFormat = function (property, paragraphData) {
        var format = new WParagraphFormat(undefined);
        var paragraphFormat = JSON.parse(paragraphData);
        var keys = Object.keys(paragraphFormat);
        this.documentEditor.documentHelper.owner.parser.parseParagraphFormat(0, JSON.parse(paragraphData), format);
        if (keys.length === 1) {
            if (keys.indexOf('styleName') !== -1) {
                this.documentEditor.editor.applyStyle(paragraphFormat.styleName, true);
            }
            else {
                if (keys[0] === 'borders') {
                    this.documentEditor.editor.onApplyParagraphFormat(keys[0], format.borders, false, false);
                }
                else {
                    this.documentEditor.editor.onApplyParagraphFormat(keys[0], paragraphFormat[keys[0]], false, false);
                }
            }
        }
        else {
            this.documentEditor.editor.updateSelectionParagraphFormatting(null, format, false);
        }
    };
    CollaborativeEditingHandler.prototype.insertTableFormat = function (type, tableData, offset) {
        var format = new WTableFormat(undefined);
        var tableFormat = JSON.parse(tableData);
        var keys = Object.keys(tableFormat);
        this.documentEditor.documentHelper.owner.parser.parseTableFormat(tableFormat, format, 0);
        var data = this.getRelativePositionFromAbsolutePosition(offset, true, false, false);
        var sourceTable = data.tableWidget;
        if (!isNullOrUndefined(type)) {
            var typeValue = type === 'TableAutoFitToContents' ? 'FitToContents' : type === 'TableAutoFitToWindow' ? 'FitToWindow' : 'FixedColumnWidth';
            this.documentEditor.editor.insertAutoFitTable(typeValue, sourceTable);
            return;
        }
        if (keys.length === 1) {
            this.documentEditor.editor.onApplyTableFormat(keys[0], tableFormat[keys[0]], sourceTable);
        }
        else {
            if (keys.indexOf('borders') !== -1 || keys.indexOf('shading') !== -1) {
                this.documentEditor.editor.isBordersAndShadingDialog = true;
                this.documentEditor.editor.onTableFormat(format, true, sourceTable);
                this.documentEditor.editor.isBordersAndShadingDialog = false;
            }
            else if (keys.indexOf('cellSpacing') !== -1 || keys.indexOf('leftMargin') !== -1 || keys.indexOf('topMargin') !== -1 || keys.indexOf('rightMargin') !== -1 || keys.indexOf('bottomMargin') !== -1) {
                this.documentEditor.documentHelper.owner.tableOptionsDialogModule.applySubTableOptions(format, sourceTable);
            }
            else {
                this.documentEditor.editor.onTableFormat(format, false, sourceTable);
            }
        }
    };
    CollaborativeEditingHandler.prototype.insertRowFormat = function (property, rowData) {
        var format = new WRowFormat(undefined);
        var rowFormat = JSON.parse(rowData);
        var keys = Object.keys(rowFormat);
        this.documentEditor.documentHelper.owner.parser.parseRowFormat(rowFormat, format, 0);
        if (keys.length === 1) {
            this.documentEditor.editor.onApplyTableRowFormat(keys[0], rowFormat[keys[0]]);
        }
        else {
            this.documentEditor.editor.onRowFormat(format);
        }
    };
    CollaborativeEditingHandler.prototype.insertCellFormat = function (cellData) {
        var format = new WCellFormat(undefined);
        var cellFormat = JSON.parse(cellData);
        var keys = Object.keys(cellFormat);
        this.documentEditor.documentHelper.owner.parser.parseCellFormat(cellFormat, format, 0);
        if (keys.length === 1) {
            if (keys[0] === 'shading') {
                this.documentEditor.editor.onApplyTableCellFormat(keys[0], format.shading);
            }
            else if (keys[0] === 'borders') {
                this.documentEditor.editor.onApplyTableCellFormat(keys[0], format.borders);
            }
            else {
                this.documentEditor.editor.onApplyTableCellFormat(keys[0], cellFormat[keys[0]]);
            }
        }
        else {
            if (keys.indexOf('preferredWidth') !== -1 || keys.indexOf('preferredWidthType') !== -1 || keys.indexOf('verticalAlignment') !== -1 || keys.indexOf('borders') !== -1 || keys.indexOf('shading') !== -1) {
                if (keys.indexOf('borders') !== -1 || keys.indexOf('shading') !== -1) {
                    this.documentEditor.editor.isBordersAndShadingDialog = true;
                }
                this.documentEditor.editor.onCellFormat(format);
                this.documentEditor.editor.isBordersAndShadingDialog = false;
            }
            else {
                this.documentEditor.documentHelper.owner.cellOptionsDialogModule.applySubCellOptions(format);
            }
        }
    };
    CollaborativeEditingHandler.prototype.insertSectionFormat = function (property, sectionData) {
        var data = JSON.parse(sectionData);
        switch (property) {
            case 'sectionFormat':
                var sectionFormat = new WSectionFormat();
                this.documentEditor.documentHelper.owner.parser.parseSectionFormat(0, data, sectionFormat);
                this.documentEditor.editor.onApplySectionFormat(undefined, sectionFormat);
                break;
            case 'linkToPrevious':
                var headerFooterWidget = this.documentEditor.selection.start.paragraph.bodyWidget;
                var sectionIndex = headerFooterWidget.sectionIndex;
                var headerFooterType = headerFooterWidget.headerFooterType;
                this.documentEditor.editor.removeInlineHeaderFooterWidget(sectionIndex, headerFooterType, property, data['linkToPrevious']);
                break;
            default:
                this.documentEditor.editor.onApplySectionFormat(Object.keys(data)[0], data[Object.keys(data)[0]]);
                break;
        }
    };
    CollaborativeEditingHandler.prototype.logMessage = function (event) {
        if (this.logEventEnabled) {
            this.message += event + ' ' + '\n';
        }
    };
    return CollaborativeEditingHandler;
}());
export { CollaborativeEditingHandler };
/**
 * @private
 */
var CaretInfo = /** @class */ (function () {
    function CaretInfo(color, caret, offset, userName) {
        this.color = color;
        this.caret = caret;
        this.offset = offset;
        this.userName = userName;
        this.initializeElement();
    }
    /**
     * @private
     */
    CaretInfo.prototype.initializeElement = function () {
        this.hoverDiv = createElement('div', { className: 'e-de-user-info e-de-user-name-collapse', styles: 'z-index: 1; visibility: hidden;left:-4px;position:absolute;width:20px;height:20px;pointer-events:all;' });
        this.userViewContainer = createElement('div');
        this.spanViewContainer = createElement('div', { styles: 'background-color:' + this.color + ';left: 0px; top: 15px; visibility: visible;' });
        this.spanView = createElement('span', { styles: 'background-color:' + this.color + '; left: 0px;top:-4px;pointer:default' });
        this.spanViewContainer.appendChild(this.spanView);
        this.userViewContainer.appendChild(this.spanViewContainer);
        this.hoverDiv.appendChild(this.userViewContainer);
        this.caret.appendChild(this.hoverDiv);
        this.hoverDiv.addEventListener('mouseenter', this.onMouseEnter.bind(this));
        this.hoverDiv.addEventListener('mouseleave', this.onMouseLeave.bind(this));
    };
    CaretInfo.prototype.onMouseEnter = function () {
        this.hoverDiv.classList.remove('e-de-user-name-collapse');
        this.hoverDiv.classList.add('e-de-user-name-expended');
        this.spanView.innerText = this.userName;
    };
    CaretInfo.prototype.onMouseLeave = function () {
        this.hoverDiv.classList.add('e-de-user-name-collapse');
        this.hoverDiv.classList.remove('e-de-user-name-expended');
        this.spanView.innerText = '';
    };
    return CaretInfo;
}());
